<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="robots" content="noindex">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="preload" href="../fonts/Alef-Regular.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="stylesheet" href="../style.css">
    <script src="p5/p5.min.js"></script>
    <noscript><style>body {visibility: visible}</style></noscript>
    <style>
        body {
            overflow: clip;
            padding: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body onload="document.body.style.visibility = 'visible'">
    <script>
        const fg = `rgb(${getComputedStyle(document.documentElement).getPropertyValue('--fg_rgb').replaceAll(' ', ', ')})`

        let values = ' ואשביעך ביהוה אלהי השמים ואלהי '
        const answer = 'ڥڬڗژ#ژڟړ#ړڟڗڜڡ#ڗژړ#ڞڜ#ڬڔڔڜڡ#ڜڗڜڗ'

        const marginFrac = .5
        const minOverlap = .15
        const animationRate = .05
        const tol = .05

        const boxWidth = 1 / ((values.length+2)+(values.length-1)*marginFrac)
        const boxes = []
        values = [...values.replace(/ך/g, 'כ').replace(/ם/g, 'מ').replace(/ן/g, 'נ').replace(/ף/g, 'פ').replace(/ץ/g, 'צ')]
        for (let i = 0; i < values.length; i++) {
            boxes.push({value: values[i], z: 0})
            boxes[i].x = boxes[i].lastX = 1 - boxWidth*(1.5+i*(1+marginFrac))
            boxes[i].y = boxes[i].lastY = .5
        }

        let boxHeight, dragIndex, dragOffsetX, dragOffsetY, solved, a

        function setup() {
            createCanvas(windowWidth, windowHeight).elt.addEventListener('dragstart', e => e.preventDefault())
            frameRate(480)
            boxHeight = boxWidth * width / height
            textAlign(CENTER, CENTER)
            textFont('Alef')
        }

        function draw() {
            background(0)
            let topZ
            boxes.toSorted((a, b) => a.z - b.z).forEach(box => topZ = drawBox(box).z)
            const candidate = boxes.reduce((s, box) => s += box.value, '')
            if (solved) {
                if (!a) {
                    a = createA((new TextEncoder).encode(candidate).join('') + '.html', 'יאשר המשך לילך שמה רשאי')
                    a.elt.focus()
                }
                a.position(0, height * .85)
                a.center('horizontal')
            } else
                solved = !topZ && ((new TextDecoder).decode((new TextEncoder).encode(candidate).map(x => x + 3)) == answer)
        }

        function drawBox(box) {
            const i = boxes.indexOf(box)
            if (i == dragIndex)
                fill(255, 224)
            else {
                const rate = min(animationRate * 60 / frameRate(), 1)
                box.x += (box.lastX-box.x) * rate
                box.y += (box.lastY-box.y) * rate
                if (abs(box.x - box.lastX) < boxWidth * tol && abs(box.y - box.lastY) < boxHeight * tol)
                    box.z = 0
                fill(solved ? fg : 224)
            }
            noStroke()
            rect((box.x-boxWidth/2) * width, (box.y-boxHeight/2) * height, boxWidth * width, boxHeight * height, 3)
            fill(0)
            textSize(boxWidth * width * .8)
            let value = box.value
            if (i != dragIndex && ((i == boxes.length - 1) || i && boxes[i + 1].value == ' '))
                value = value.replace('כ', 'ך').replace('מ', 'ם').replace('נ', 'ן').replace('פ', 'ף').replace('צ', 'ץ')
            text(value, box.x * width, box.y * height)
            return box
        }

        function getOverlap(box1, box2) {
            let overlapX = max(0, (min(box1.x, box2.x)-max(box1.x, box2.x))/boxWidth + 1)
            let overlapY = max(0, (min(box1.y, box2.y)-max(box1.y, box2.y))/boxHeight + 1)
            return overlapX * overlapY
        }

        function mousePressed() {
            if (solved || mouseButton && mouseButton != 'left')  // https://github.com/processing/p5.js/issues/7397
                return
            const mX = mouseX / width
            const mY = mouseY / height
            for (let i = 0; i < boxes.length; i++)
                if (abs(mX - boxes[i].x) < boxWidth / 2 && abs(mY - boxes[i].y) < boxHeight * height / 2) {
                    dragIndex = i
                    dragOffsetX = (boxes[i].x-mX) / boxWidth
                    dragOffsetY = (boxes[i].y-mY) / boxHeight
                    boxes[i].z = max(boxes.map(box => box.z)) + 1
                    break
                }
        }

        function mouseDragged() {
            if (dragIndex == null)
                return
            boxes[dragIndex].x = mouseX/width + dragOffsetX*boxWidth
            boxes[dragIndex].y = mouseY/height + dragOffsetY*boxHeight
            let targetIndex
            let bestOverlap = minOverlap
            for (let i = 0; i < boxes.length; i++)
                if (!boxes[i].z) {
                    const overlap = getOverlap(boxes[i], boxes[dragIndex])
                    if (overlap > bestOverlap) {
                        bestOverlap = overlap
                        targetIndex = i
                    }
                }
            if (targetIndex != null) {
                const {value, x, y, z} = boxes[dragIndex]
                boxes[dragIndex].value = boxes[targetIndex].value
                boxes[dragIndex].x = boxes[targetIndex].x
                boxes[dragIndex].y = boxes[targetIndex].y
                boxes[targetIndex].value = value
                boxes[targetIndex].x = x
                boxes[targetIndex].y = y
                boxes[targetIndex].z = z + 1
                dragIndex = targetIndex
            }
        }

        function mouseReleased() {
            dragIndex = null
        }

        addEventListener('blur', mouseReleased)

        // https://github.com/processing/p5.js/issues/7195
        function touchStarted() {
            mousePressed()
        }
        function touchMoved() {
            mouseDragged()
        }
        function touchEnded() {
            if (!touches.length)
                mouseReleased()
        }

        function windowResized() {
            resizeCanvas(document.documentElement.clientWidth, document.documentElement.clientHeight)  // Needed for orientation change on Chrome Android. See: https://github.com/processing/p5.js/issues/8121
            boxHeight = boxWidth * width / height
        }
    </script>
</body>
</html>