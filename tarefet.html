<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Alef:wght@400;700&display=block" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.10/lib/p5.min.js"></script>
    <style>
        body {
            font-family: Alef, sans-serif;
            margin: 0;
            overflow: clip;
        }

        a:focus-visible {
            outline: transparent;
        }

        button, span {
            font-family: inherit;
            font-size: 1.2em;
        }

        canvas {
            display: block;
        }

        header {
            box-sizing: border-box;
            padding-inline: 1em;
            position: absolute;
            text-align: center;
            text-wrap: balance;
            width: 100%;
        }

        @media (max-height: 600px) {
            h1, h2 {
                display: inline;
                margin-bottom: 0;
            }

            h2 {
                margin-inline-start: 3em;
            }

            h3 {
                margin-top: 0;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>טַרֶפֶת אותיות</h1>
        <h2>יעל צברי ואיל יהוה גרוּס</h2>
        <h3><u>הוראות:</u> סדרו את המלבנים כך שייווצר ביטוי חדש בן שתי מילים</h3>
    </header>
    <script>
        'use strict'

        let anagrams = `
אדם דגול,דגל אדום
אוהדת ביתר,תיבת הדואר
אוצר לאומי,מוציא לאור
אי ספיקה,אייס קפה
דליפת האמוניה,אליפות המדינה
בחירות האמצע,אמצעי תחבורה
אתי חפירה,חיה פראית
חבטתי בו,בוטחת בי
בחדר המנוחה,בחורה נחמדה
בחיל הים,הילחם בי
רובה צייד,ביד היוצר
נע במהירות,בימת הנוער
בלתי עביר,בעלי ברית
מודה לבורא,במלוא הדרו
במענה הקולי,הבנק העולמי
בצל ירוק,בקר צלוי
בר יוחאי,חי ובריא
בתזמון מושלם,תשלום במזומן
חג מולד,דג מלוח
נומי ילדה,דמי ניהול
האוויר הקר,האור הירוק
שכה אהבת,האש כבתה
שאמשיך הלאה,האשך השמאלי
הבין לאומית,הבלתי יאומן
הבלתי פוסקת,תפסיק לבהות
לעליית הגג,הגעתי לגיל
החדיש ביותר,חדר הישיבות
החזיקו ידיים,זיהום חיידקי
השחור והלבן,החלון השבור
הישאר רגוע,רגעי האושר
הלכו לפח,לוח הכפל
השיער הארוך,העורך הראשי
העמוס ביותר,מוות בעריסה
העפתי מבט,מפי הטבעת
העתיד הרחוק,ועדת החקירה
ודרום אמריקה,מדרום קוריאה
ולהתחיל מחדש,מתחילה לחשוד
חברי כנופיות,כנופיית רחוב
חברת בנייה,נתיב בריחה
לחדר מיון,חדרי מלון
חוסר משמעת,חסר משמעות
קרח יבש,חי בשקר
חיוורי פנים,פינוי חירום
חיל השלום,חילול השם
לוי יצחק,חצי קילו
ידוע מראש,עמוד ראשי
ירה בעצמו,רבי עוצמה
ישו הנוצרי,שינוי צורה
לכביש המהיר,כלבי השמירה
מאב לבן,לב מאבן
להתנקם בי,להקת בנים
מאגיה שחורה,שגיאה חמורה
משוך לאחור,מחושך לאור
נוהג במכונית,מכונית גנובה
מת ונקבר,מנות קרב
מנקה חלונות,נחנקה למוות
עונת המסיק,מסע הקניות
מרוצי סוסים,סוס מירוצים
נורה בחזה,רחב הזונה
רגש אנושי,נושא רגיש
עשר דקות,עדות שקר
רך ועדין,עורך דין
עצי אורן,רועי צאן
פצע ירי,עצי פרי
קבעתי תור,עקרות בית
קומה חמישית,שיחה מקומית
רפואת חירום,רוחות רפאים
`

        anagrams = anagrams.trim().split('\n').filter(anagram => anagram.split(',')[0].trim().length == anagram.split(',')[1].trim().length)
        const match = location.search.slice(1).match(/^\d+$/)?.[0]
        const index = match ?? localStorage['tarefet'] | 0
        localStorage['tarefet'] = index

        let [values, answer] = anagrams[index].split(',')
        values = [...values.trim().replace(/ך/g, 'כ').replace(/ם/g, 'מ').replace(/ן/g, 'נ').replace(/ף/g, 'פ').replace(/ץ/g, 'צ')]
        answer = answer.trim().replace(/ך/g, 'כ').replace(/ם/g, 'מ').replace(/ן/g, 'נ').replace(/ף/g, 'פ').replace(/ץ/g, 'צ')

        const marginFrac = .5
        const minOverlap = .15
        const animationRate = .05
        const tol = .05

        const boxWidth = 1 / ((values.length+2)+(values.length-1)*marginFrac)

        function boxHeight() {
            return max(boxWidth, 100 / width)
        }

        const boxes = []
        for (let i = 0; i < values.length; i++) {
            boxes.push({value: values[i], z: 0})
            boxes[i].x = boxes[i].lastX = 1 - boxWidth*(1.5+i*(1+marginFrac))
            boxes[i].y = boxes[i].lastY = .5
        }

        let dragIndex, dragOffsetX, dragOffsetY, isOrdered, clue, a

        function getClue() {
            clue.remove()
            clue = createSpan(`רמז: ${answer.split(' ')[0].length} אותיות, ${answer.split(' ')[1].length} אותיות`)
        }

        function setup() {
            createCanvas(windowWidth, windowHeight).elt.addEventListener('dragstart', e => e.preventDefault())
            cursor('grab')
            frameRate(480)
            textAlign(CENTER, CENTER)
            textFont('Alef')
            clue = createButton('תן רמז')
            clue.mouseClicked(getClue)
        }

        function draw() {
            background(255)
            let topZ = 0
            boxes.toSorted((a, b) => a.z - b.z).forEach(box => topZ = drawBox(box).z)
            const candidate = boxes.reduce((s, box) => s += box.value, '')
            if (isOrdered) {
                clue.hide()
                if (!a) {
                    a = createA(`${location.pathname}?${index+1}`, 'לאתגר הבא')
                    a.elt.focus()
                }
                a.position(0, height * .85)
                a.center('horizontal')
            } else {
                isOrdered = !topZ && candidate == answer
                if (clue) {
                    clue.position(0, height * .85)
                    clue.center('horizontal')
                }
            }
        }

        function drawBox(box) {
            const i = boxes.indexOf(box)
            if (i == dragIndex)
                fill(38, 185, 241, 224)
            else {
                const rate = animationRate * 60 / frameRate()
                box.x += (box.lastX-box.x) * rate
                box.y += (box.lastY-box.y) * rate
                if (abs(box.x - box.lastX) < boxWidth * tol && abs(box.y - box.lastY) < boxHeight() * tol)
                    box.z = 0
                fill(isOrdered ? '#64ff64' : 192)
            }
            noStroke()
            rect((box.x-boxWidth/2) * width, box.y*height - boxHeight()/2*width , boxWidth * width, boxHeight() * width, 3)
            fill(0)
            textSize(boxWidth * width * .8)
            let value = box.value
            if (i != dragIndex && ((i == boxes.length - 1) || boxes[i + 1].value == ' '))
                value = value.replace('כ', 'ך').replace('מ', 'ם').replace('נ', 'ן').replace('פ', 'ף').replace('צ', 'ץ').replace('ץ', 'צ')
            text(value, box.x * width, box.y * height)
            return box
        }

        function getOverlap(box1, box2) {
            let overlapX = max(0, (min(box1.x, box2.x)-max(box1.x, box2.x))/boxWidth + 1)
            let overlapY = max(0, (min(box1.y, box2.y)-max(box1.y, box2.y))/boxHeight() + 1)
            return overlapX * overlapY
        }

        function mousePressed() {
            if (isOrdered || mouseButton && mouseButton != 'left')  // https://github.com/processing/p5.js/issues/7397
                return
            const mX = mouseX / width
            const mY = mouseY / height
            for (let i = 0; i < boxes.length; i++)
                if (abs(mX - boxes[i].x) < boxWidth / 2 && abs(mY - boxes[i].y) < boxHeight() / 2) {
                    cursor('grabbing')
                    dragIndex = i
                    dragOffsetX = boxes[i].x - mX
                    dragOffsetY = boxes[i].y - mY
                    boxes[i].z = max(boxes.map(box => box.z)) + 1
                    break
                }
        }

        function mouseDragged() {
            if (dragIndex == null)
                return
            boxes[dragIndex].x = mouseX/width + dragOffsetX
            boxes[dragIndex].y = mouseY/height + dragOffsetY
            let targetIndex
            let bestOverlap = minOverlap
            for (let i = 0; i < boxes.length; i++)
                if (!boxes[i].z) {
                    const overlap = getOverlap(boxes[i], boxes[dragIndex])
                    if (overlap > bestOverlap) {
                        bestOverlap = overlap
                        targetIndex = i
                    }
                }
            if (targetIndex != null) {
                const {value, x, y, z} = boxes[dragIndex]
                boxes[dragIndex].value = boxes[targetIndex].value
                boxes[dragIndex].x = boxes[targetIndex].x
                boxes[dragIndex].y = boxes[targetIndex].y
                boxes[targetIndex].value = value
                boxes[targetIndex].x = x
                boxes[targetIndex].y = y
                boxes[targetIndex].z = z + 1
                dragIndex = targetIndex
            }
        }

        function mouseReleased() {
            cursor('grab')
            dragIndex = null
        }

        addEventListener('blur', mouseReleased)

        // https://github.com/processing/p5.js/issues/7195
        function touchStarted() {
            mousePressed()
        }
        function touchMoved() {
            mouseDragged()
        }
        function touchEnded() {
            mouseReleased()
        }

        function windowResized() {
            resizeCanvas(document.documentElement.clientWidth, document.documentElement.clientHeight)  // Using client for Chrome Android. See: https://github.com/processing/p5.js/issues/8121
        }
    </script>
</body>
</html>